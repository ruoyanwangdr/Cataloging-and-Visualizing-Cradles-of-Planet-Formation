<html>
	<head>
		<title>DiskModelTest</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script type="text/javascript" src="js/libs/dat.gui.min.js"> </script>
		<script src="js/three.js"></script>
		<script src="js/controls/OrbitControls.js"></script>
		<script>
		///////////////////////////
		// Camera and Background //
		///////////////////////////
		var scene, camera, renderer;
		var gui, pointLight, sphere, disk;

		function init(){
				scene = new THREE.Scene();
				//scene.add( new THREE.AmbientLight( 0x111122 ) );

				renderer = new THREE.WebGLRenderer({antialias: true});
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;

				renderer.shadowMap.type = THREE.BasicShadowMap;
				document.body.appendChild(renderer.domElement);

				var camera_params = {
						fov: 45,
						aspect: window.innerWidth/window.innerHeight,
						near: 0.1,
						far: 1000
				};
				camera = new THREE.PerspectiveCamera(
						camera_params.fov,
						camera_params.aspect,
						camera_params.near,
						camera_params.far);
				controls = new THREE.OrbitControls( camera, renderer.domElement );

				// controls.update() must be called after any manual changes to the camera's transform
				camera.position.set( 0, 0, 70 );
				controls.target.set(0, 0, 0);
				controls.update();

				displaygui();
				createLight();

		}
		function createLight() {
				params = {
						color: 0xffffff,
						intensity: 10,
						distance: 20,
				};
				pointLight = new THREE.PointLight(
						params.color,
						params.intensity,
						params.distance);
				pointLight.castShadow = true;
				pointLight.shadow.camera.near = 0.001;
				pointLight.shadow.camera.far = 10000;
				pointLight.shadow.bias = - 0.005; // reduces self-shadowing on double-sided objects

				var sphere_geometry = new THREE.SphereGeometry( 1.5, 48, 48 );
				var sphere_material = new THREE.MeshBasicMaterial( {
						color: params.color,
						side: THREE.DoubleSide,
						alphaTest: 0.5
				} );
				//material.color.multiplyScalar( params.intensity );
				sphere = new THREE.Mesh(sphere_geometry, sphere_material);
				sphere.castShadow = true;
							//sphere.receiveShadow = true;
							//sphere.shadowDarkness = 0.5;
							//sphere.shadowCameraVisible = true;
				pointLight.add(sphere);


				var points = [];
				//for ( var i = 0; i < 10; i ++ ) {
				//	points.push( new THREE.Vector2( Math.sin( i * 0.2 ) * 10 + 5, ( i - 5 ) * 2 ) );
				points.push( new THREE.Vector3( 5, -0.1, 0 ) );
				points.push( new THREE.Vector3( 6, -0.15, 0 ) );
				points.push( new THREE.Vector3( 8, -1, 0 ) );
				points.push( new THREE.Vector3( 10, -1.5, 0 ) );
				points.push( new THREE.Vector3( 13, -3, 0 ) );
				points.push( new THREE.Vector3( 13.4, 0, 0 ) );
				points.push( new THREE.Vector3( 13, 3, 0 ) );
				points.push( new THREE.Vector3( 10, 1.5, 0 ) );
				points.push( new THREE.Vector3( 8, 1, 0 ) );
				points.push( new THREE.Vector3( 6, 0.15, 0 ) );
				points.push( new THREE.Vector3( 5, 0.1, 0 ) );
				points.push( new THREE.Vector3( 5, -0.1, 0 ) );

				// Make a spline curve to interpolate the curve between the points
				var curve = new THREE.CatmullRomCurve3(points);
				// then specify the number of points on that curve and make it into an array of points
				var numPoints = 50;
				var splinePoints = curve.getPoints(numPoints);

				// Make a new lathe geometry out of of the array of points just created
				var disk_geometry = new THREE.LatheGeometry( splinePoints, segments=36 );
				var disk_material = new THREE.MeshPhysicalMaterial( {
						color: 0xffffff,
						vertexColors: THREE.FaceColors,
						side: THREE.DoubleSide,
						roughness: 1,
					} );
				disk = new THREE.Mesh(disk_geometry, disk_material);
				disk.receiveShadow = true;
				disk.rotation.x = - Math.PI / 2.0 ;

				pointLight.add( disk );
				scene.add(pointLight);

				return pointLight;
		}

		function displaygui(){
				var gui = new dat.GUI();
				var light = gui.addFolder('Light');
				var jar;
				parameters = {
						color: 0xffffff,
						intensity: 10,
						distance: 20,
				};
				var color = light.addColor(parameters, 'color');
				var intensity = light.add(parameters, 'intensity').min(0).max(20).step(1);
				var distance = light.add(parameters, 'distance').min(0).max(30).step(1);

				color.onChange(function(jar){sphere.material.color.setHex(jar.toString().replace("#","0x"
						));});
				intensity.onChange(function(jar){pointLight.params.intensity = jar});
				gui.open()
		}
		function animate(){
				disk.geometry.colorNeedUpdate = true;
				requestAnimationFrame(animate);
				render();
		}
		function render(){
				renderer.clear();
				renderer.render(scene, camera);
		}
		init();
		animate();

		</script>
	</body>
</html>
