<html>
	<head>
		<title>DiskModelTest</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script type="text/javascript" src="js/libs/dat.gui.min.js"> </script>
		<script src="js/three.js"></script>
		<script src="js/controls/OrbitControls.js"></script>
		<script>
		///////////////////////////
		// Camera and Background //
		///////////////////////////
		var scene, camera, renderer;
		var gui, sphere;

		function init(){
				scene = new THREE.Scene();
				scene.add( new THREE.AmbientLight( 0x111122 ) );

				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;

				renderer.shadowMap.type = THREE.BasicShadowMap;
				document.body.appendChild(renderer.domElement);

				var camera_params = {
						fov: 45,
						aspect: window.innerWidth/window.innerHeight,
						near: 0.1,
						far: 1000
				};
				camera = new THREE.PerspectiveCamera(
						camera_params.fov,
						camera_params.aspect,
						camera_params.near,
						camera_params.far);
				controls = new THREE.OrbitControls( camera, renderer.domElement );

				// controls.update() must be called after any manual changes to the camera's transform
				camera.position.set( 0, 0, 70 );
				controls.target.set(0, 0, 0);
				controls.update();

				displaygui();
				createLight();
				disk();

		}
		function createLight() {
				params = {
						color: 0xffffff,
						intensity: 10,
						distance: 20,
				};
				var pointLight = new THREE.PointLight(
						params.color,
						params.intensity,
						params.distance);
				pointLight.castShadow = true;
				pointLight.shadow.camera.near = 0.001;
				pointLight.shadow.camera.far = 6000;
				pointLight.shadow.bias = - 0.005; // reduces self-shadowing on double-sided objects

				var geometry = new THREE.SphereGeometry( 1.5, 48, 48 );
				var material = new THREE.MeshBasicMaterial( {
						color: params.color,
						side: THREE.DoubleSide,
						alphaTest: 0.5
				} );
				material.color.multiplyScalar( params.intensity );
				sphere = new THREE.Mesh( geometry, material );
				sphere.castShadow = true;
							//sphere.receiveShadow = true;
							//sphere.shadowDarkness = 0.5;
							//sphere.shadowCameraVisible = true;
				pointLight.add(sphere);

							//var texture = new THREE.CanvasTexture( generateTexture() );
							//texture.magFilter = THREE.NearestFilter;
							//texture.wrapT = THREE.RepeatWrapping;
							//texture.wrapS = THREE.RepeatWrapping;
							//texture.repeat.set( 1, 4.5 );

							// custom distance material
				var distanceMaterial = new THREE.MeshDistanceMaterial({
						alphaMap: material.alphaMap,
						alphaTest: material.alphaTest
				});
				sphere.customDistanceMaterial = distanceMaterial;
				scene.add(pointLight);
				return pointLight;
		}
		function disk(){
			// Create an array of points
			var points = [];
			//for ( var i = 0; i < 10; i ++ ) {
			//	points.push( new THREE.Vector2( Math.sin( i * 0.2 ) * 10 + 5, ( i - 5 ) * 2 ) );
			points.push( new THREE.Vector3( 5, -0.1, 0 ) );
			points.push( new THREE.Vector3( 6, -0.15, 0 ) );
			points.push( new THREE.Vector3( 8, -1, 0 ) );
			points.push( new THREE.Vector3( 10, -1.5, 0 ) );
			points.push( new THREE.Vector3( 13, -3, 0 ) );
			points.push( new THREE.Vector3( 13.4, 0, 0 ) );
			points.push( new THREE.Vector3( 13, 3, 0 ) );
			points.push( new THREE.Vector3( 10, 1.5, 0 ) );
			points.push( new THREE.Vector3( 8, 1, 0 ) );
			points.push( new THREE.Vector3( 6, 0.15, 0 ) );
			points.push( new THREE.Vector3( 5, 0.1, 0 ) );
			points.push( new THREE.Vector3( 5, -0.1, 0 ) );

			// Make a spline curve to interpolate the curve between the points
			var curve = new THREE.CatmullRomCurve3(points);
			// then specify the number of points on that curve and make it into an array of points
			var numPoints = 50;
			var splinePoints = curve.getPoints(numPoints);

			// Make a new lathe geometry out of of the array of points just created
			var geometry = new THREE.LatheGeometry( splinePoints, segments=36 );
			var material = new THREE.MeshPhysicalMaterial( {
					color: 0xffffff,
					vertexColors: THREE.FaceColors,
					//shininess: 10,
					//specular: 0x111111,
					side: THREE.DoubleSide,
					roughness: 1,
				} );
			var disk = new THREE.Mesh( geometry, material );
			disk.receiveShadow = true;
			disk.rotation.x = - Math.PI / 2.0 ;
			//helper.rotation.x = - Math.PI / 2.0 ;
			//var numberFaceNornal = disk.geometry.faces.length;
			//console.log(faceNornal);
			//for (i = 0; i < numberFaceNornal; i++) {
			//	zVal = disk.geometry.faces[i].normal;
				//console.log(zVal);
			//	setcolor = disk.geometry.faces[i].color.setRGB(Math.abs(zVal.x),Math.abs(zVal.y), Math.abs(zVal.z));
				//console.log(setcolor);
				//console.log(zVal);
				//text += cars[i] + "<br>";
			//}
			var helper = new THREE.FaceNormalsHelper( disk, 1, 0x00ff00, 1 );
			//console.log(helper);
			scene.add( disk );
		}

		function displaygui(){
				var gui = new dat.GUI();
				var jar;
				parameters = {
						color: 0xffffff,
						intensity: 10,
						distance: 20,
				};
				var color = gui.addColor(parameters, 'color');
				var intensity = gui.add(parameters, 'intensity').min(0).max(20).step(1);
				gui.add(parameters, 'distance').min(0).max(30).step(1);

				color.onChange(function(jar){sphere.material.color.setHex(jar.toString().replace("#","0x"
						));});
				//intensity.onChange(function(jar){sphere.})
				gui.open()
		}
		function animate(){
				requestAnimationFrame(animate);
				render();
		}
		function render(){
				renderer.clear();
				renderer.render(scene, camera);
		}
		init();
		animate();

		</script>
	</body>
</html>
