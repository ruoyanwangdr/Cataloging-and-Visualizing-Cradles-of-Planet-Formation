<html>
	<head>
		<title>CircumstellarDiskModel</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script src="js/controls/OrbitControls.js"></script>
		<script>
			///////////////////////////
			// Camera and Background //
			///////////////////////////

			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.shadowMap.enabled = true;

			renderer.shadowMap.type = THREE.BasicShadowMap;
			document.body.appendChild( renderer.domElement );

			var scene = new THREE.Scene();
			scene.add( new THREE.AmbientLight( 0x111122 ) );
			var camera = new THREE.PerspectiveCamera( 45, window.innerWidth/window.innerHeight, 1, 10000 );
			console.log(camera);
			var pointLight, pointLight2;
			var controls = new THREE.OrbitControls( camera, renderer.domElement );

			// controls.update() must be called after any manual changes to the camera's transform
			camera.position.set( 0, 0, 70 );
			//camera.position.z = 70;
			controls.update();

			///////////
			// Light //
			///////////

			// Texture
			function generateTexture() {
				var canvas = document.createElement( 'canvas' );
				canvas.width = 2;
				canvas.height = 2;
				var context = canvas.getContext( '2d' );
				context.fillStyle = 'white';
				context.fillRect( 0, 1, 2, 1 );
				return canvas;
			}

			// Shadow light from the light source at center
			function createLight( color, intensity, distance ) {
								//var intensity = 5;

								var pointLight = new THREE.PointLight( color, intensity, distance );
								pointLight.castShadow = true;
								pointLight.shadow.camera.near = 0.001;
								pointLight.shadow.camera.far = 6000;
								pointLight.shadow.bias = - 0.005; // reduces self-shadowing on double-sided objects

								var geometry = new THREE.SphereBufferGeometry( 2, 32, 8 );
								var material = new THREE.MeshBasicMaterial( {
									color: color,
									side: THREE.DoubleSide,
									alphaTest: 0.5
								} );
								material.color.multiplyScalar( intensity );
								var sphere = new THREE.Mesh( geometry, material );
								sphere.castShadow = true;
								//sphere.receiveShadow = true;
								//sphere.shadowDarkness = 0.5;
								//sphere.shadowCameraVisible = true;
								pointLight.add( sphere );

								var texture = new THREE.CanvasTexture( generateTexture() );
								texture.magFilter = THREE.NearestFilter;
								texture.wrapT = THREE.RepeatWrapping;
								texture.wrapS = THREE.RepeatWrapping;
								texture.repeat.set( 1, 4.5 );

								// custom distance material
								var distanceMaterial = new THREE.MeshDistanceMaterial( {
									alphaMap: material.alphaMap,
									alphaTest: material.alphaTest
								} );
								sphere.customDistanceMaterial = distanceMaterial;
								return pointLight;
			}

			var pointLight = createLight( 0xFFffff, 2.	5, 20 );
			scene.add( pointLight );


			//////////
			// Disk //
			//////////

			// Create an array of points
			var points = [];
			//for ( var i = 0; i < 10; i ++ ) {
			//	points.push( new THREE.Vector2( Math.sin( i * 0.2 ) * 10 + 5, ( i - 5 ) * 2 ) );
			points.push( new THREE.Vector3( 5, -0.1, 0 ) );
			points.push( new THREE.Vector3( 6, -0.15, 0 ) );
			points.push( new THREE.Vector3( 8, -1, 0 ) );
			points.push( new THREE.Vector3( 10, -1.5, 0 ) );
			points.push( new THREE.Vector3( 13, -3, 0 ) );
			points.push( new THREE.Vector3( 13.4, 0, 0 ) );
			points.push( new THREE.Vector3( 13, 3, 0 ) );
			points.push( new THREE.Vector3( 10, 1.5, 0 ) );
			points.push( new THREE.Vector3( 8, 1, 0 ) );
			points.push( new THREE.Vector3( 6, 0.15, 0 ) );
			points.push( new THREE.Vector3( 5, 0.1, 0 ) );
			points.push( new THREE.Vector3( 5, -0.1, 0 ) );

			// Make a spline curve to interpolate the curve between the points
			var curve = new THREE.CatmullRomCurve3(points);
			// then specify the number of points on that curve and make it into an array of points
			var numPoints = 50;
			var splinePoints = curve.getPoints(numPoints);

			// Make a new lathe geometry out of of the array of points just created
			//var geometry = new THREE.LatheGeometry( splinePoints,10,0,Math.PI);
			var geometry = new THREE.LatheGeometry( splinePoints, segments=36 );
			//geometry.scale(-1,1,1);
			var material = new THREE.MeshPhysicalMaterial( {
					color: 0xffffff,
					vertexColors: THREE.FaceColors,
					//shininess: 10,
					//specular: 0x111111,
					side: THREE.DoubleSide,
				} );
			//var material = new THREE.MeshNormalMaterial({opacity : 0.5,
			//	transparent: false,
			//	wireframe: false,
			//	side: THREE.DoubleSide});
			var disk = new THREE.Mesh( geometry, material );
			disk.receiveShadow = true;
			//disk.shadowDarkness = 0.5;
			//disk.shadowCameraVisible = true;

			disk.rotation.x = - Math.PI / 2.0 ;
			//helper.rotation.x = - Math.PI / 2.0 ;
			//var numberFaceNornal = disk.geometry.faces.length;
			//console.log(faceNornal);
			//for (i = 0; i < numberFaceNornal; i++) {
			//	zVal = disk.geometry.faces[i].normal;
				//console.log(zVal);
			//	setcolor = disk.geometry.faces[i].color.setRGB(Math.abs(zVal.x),Math.abs(zVal.y), Math.abs(zVal.z));
				//console.log(setcolor);
				//console.log(zVal);
				//text += cars[i] + "<br>";
			//}
			scene.add( disk );
			//console.log(disk);
			//scene.add( helper );

			//////////////////
			// Polarization //
			//////////////////

			//var helper = new THREE.FaceNormalsHelper( disk, 1, 0x00ff00, 1 );

			//var faceCoordinates = geometry.computeFaceNormals();
			//var faceNumber = disk.geometry.faces[0].normal;

			//var numberFaceNornal = disk.geometry.faces.length;
			//console.log(faceNornal);
			//for (i = 0; i < numberFaceNornal; i++) {
			//	zVal = Math.abs(disk.geometry.faces[i].normal);
			//	disk.geometry.faces[i].color.setRGB(zVal);
				//console.log(zVal);
				//text += cars[i] + "<br>";
			//}

			//var a = new THREE.Vector3( pointLight );
			//var b = new THREE.Vector3( faceCoordinates );
			//var intensityPolar = Math.pow( a.dot( b ), 2 );
			//pointLight2 = createLight( 0xff8888 );
			//scene.add( pointLight2 );

			//for (i = 0; i < helper.length; i++) {
			//	text += cars[i] + "<br>";
			//}
			//var pointLight = createLight( 0x0088ff, 5 );
			//scene.add( pointLight );

			//geometry.computeVertexNormals();
			//geometry.computeFlatVertexNormals();

			/*
			var loader = new THREE.FontLoader();

			loader.load( 'https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function ( font ) {

				var geometry = new THREE.TextGeometry( 'Hello three.js!', {
					font: font,
					size: 80,
					height: 5,
					curveSegments: 12,
					bevelEnabled: true,
					bevelThickness: 10,
					bevelSize: 8,
					bevelOffset: 0,
					bevelSegments: 5
				} );
			} );
			*/


			///////////////////
			// Shape display //
			///////////////////

			// Create a closed wavey loop to see the shape
			var points = curve.getPoints( 50 );
			var geometry = new THREE.BufferGeometry().setFromPoints( points );

			var material = new THREE.LineBasicMaterial( { color : 0xff0000 } );

			// Create the final object to add to the scene
			var curveObject = new THREE.Line( geometry, material );
			curveObject.position.set(20, 0, 0)
			scene.add(curveObject)

			/////////////
			// Animate //
			/////////////

			var animate = function () {
				requestAnimationFrame( animate );

				var numberFaceNornal = disk.geometry.faces.length;
				initialVector = new THREE.Vector3( 5, -0.1, 0 );
				colorVector = camera.getWorldDirection(initialVector);
				//console.log(faceNornal);
				for (i = 0; i < numberFaceNornal; i++) {
					//zVal = disk.geometry.faces[i].normal;
					//console.log(zVal);
					//setcolor = disk.geometry.faces[i].color.setRGB(Math.random(),Math.abs(zVal.y), Math.abs(zVal.z));
					setColor = disk.geometry.faces[i].color.setRGB(
						Math.abs(colorVector.x),
						Math.abs(colorVector.y),
						Math.abs(colorVector.z),
					);

					//console.log(setcolor);
					//console.log(zVal);
					//text += cars[i] + "<br>";
				}
				disk.geometry.elementsNeedUpdate = true;
				//console.log(camera.getWorldDirection());
				//console.log(color_vector);

				renderer.render( scene, camera );
			};

			animate();
		</script>
	</body>
</html>
