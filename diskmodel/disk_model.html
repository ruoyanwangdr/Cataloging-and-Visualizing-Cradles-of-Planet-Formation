<html>
	<head>
		<title>DiskModel</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script type="text/javascript" src="js/libs/dat.gui.min.js"> </script>
		<script src="js/three.js"></script>
		<script src="js/controls/OrbitControls.js"></script>
		<script>
			///////////////////////////
			// Camera and Background //
			///////////////////////////
			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.shadowMap.enabled = true;

			renderer.shadowMap.type = THREE.BasicShadowMap;
			document.body.appendChild( renderer.domElement );

			var scene = new THREE.Scene();
			scene.add( new THREE.AmbientLight( 0x111122 ) );
			var camera = new THREE.PerspectiveCamera( 45, window.innerWidth/window.innerHeight, 1, 10000 );

			//var cameraHelper = new THREE.CameraHelper(camera);
			//scene.add(cameraHelper);


			var pointLight;

			var controls = new THREE.OrbitControls( camera, renderer.domElement );

			// controls.update() must be called after any manual changes to the camera's transform
			camera.position.set( 0, 30, 70 );
			controls.update();


			///////////
			// Light //
			///////////

			// Texture
			function generateTexture() {
				var canvas = document.createElement( 'canvas' );
				canvas.width = 2;
				canvas.height = 2;
				var context = canvas.getContext( '2d' );
				context.fillStyle = 'white';
				context.fillRect( 0, 1, 2, 1 );
				return canvas;
			}

			// Shadow light from the light source at center
			function createLight( color, intensity, distance ) {
								var pointLight = new THREE.PointLight( color, intensity, distance );
								pointLight.castShadow = true;
								pointLight.shadow.camera.near = 0.001;
								pointLight.shadow.camera.far = 6000;
								pointLight.shadow.bias = - 0.005; // reduces self-shadowing on double-sided objects

								var geometry = new THREE.SphereGeometry( 1.5, 48, 48 );
								var material = new THREE.MeshBasicMaterial( {
									color: color,
									side: THREE.DoubleSide,
									alphaTest: 0.5
								} );
								material.color.multiplyScalar( intensity );
								var sphere = new THREE.Mesh( geometry, material );
								sphere.castShadow = true;
								//sphere.receiveShadow = true;
								//sphere.shadowDarkness = 0.5;
								//sphere.shadowCameraVisible = true;
								pointLight.add( sphere );

								//var texture = new THREE.CanvasTexture( generateTexture() );
								//texture.magFilter = THREE.NearestFilter;
								//texture.wrapT = THREE.RepeatWrapping;
								//texture.wrapS = THREE.RepeatWrapping;
								//texture.repeat.set( 1, 4.5 );

								// custom distance material
								var distanceMaterial = new THREE.MeshDistanceMaterial( {
									alphaMap: material.alphaMap,
									alphaTest: material.alphaTest
								} );
								sphere.customDistanceMaterial = distanceMaterial;
								return pointLight;
			}
			var params = {
					color: 0xffffff,
					intensity: 20,
					distance: 20,
			};

			var pointLight = createLight(
				params.color,
				params.intensity,
				params.distance
			);
			scene.add( pointLight );


			//////////
			// Disk //
			//////////

			// Create an array of points
			var points = [];
			//for ( var i = 0; i < 10; i ++ ) {
			//	points.push( new THREE.Vector2( Math.sin( i * 0.2 ) * 10 + 5, ( i - 5 ) * 2 ) );
			points.push( new THREE.Vector3( 5, -0.1, 0 ) );
			points.push( new THREE.Vector3( 6, -0.15, 0 ) );
			points.push( new THREE.Vector3( 8, -1, 0 ) );
			points.push( new THREE.Vector3( 10, -1.5, 0 ) );
			points.push( new THREE.Vector3( 13, -3, 0 ) );
			points.push( new THREE.Vector3( 13.4, 0, 0 ) );
			points.push( new THREE.Vector3( 13, 3, 0 ) );
			points.push( new THREE.Vector3( 10, 1.5, 0 ) );
			points.push( new THREE.Vector3( 8, 1, 0 ) );
			points.push( new THREE.Vector3( 6, 0.15, 0 ) );
			points.push( new THREE.Vector3( 5, 0.1, 0 ) );
			points.push( new THREE.Vector3( 5, -0.1, 0 ) );

			// Make a spline curve to interpolate the curve between the points
			var curve = new THREE.CatmullRomCurve3(points);
			// then specify the number of points on that curve and make it into an array of points
			var numPoints = 50;
			var splinePoints = curve.getPoints(numPoints);

			// Make a new lathe geometry out of of the array of points just created
			var geometry = new THREE.LatheGeometry( splinePoints, segments=36 );
			var material = new THREE.MeshPhysicalMaterial( {
					color: 0xffffff,
					vertexColors: THREE.FaceColors,
					//shininess: 10,
					//specular: 0x111111,
					side: THREE.DoubleSide,
					roughness: 1,
				} );
			var disk = new THREE.Mesh( geometry, material );
			disk.receiveShadow = true;
			disk.rotation.x = - Math.PI / 2.0 ;

			var helper = new THREE.FaceNormalsHelper( disk, 1, 0x00ff00, 1 );
			//console.log(helper);
			scene.add( disk );
			//scene.add( helper );

			//////////////////
			// Polarization //
			//////////////////

			//var helper = new THREE.FaceNormalsHelper( disk, 1, 0x00ff00, 1 );

			//var faceCoordinates = geometry.computeFaceNormals();
			//var faceNumber = disk.geometry.faces[0].normal;

			//var numberFaceNornal = disk.geometry.faces.length;
			//console.log(faceNornal);
			//for (i = 0; i < numberFaceNornal; i++) {
			//	zVal = Math.abs(disk.geometry.faces[i].normal);
			//	disk.geometry.faces[i].color.setRGB(zVal);
				//console.log(zVal);
				//text += cars[i] + "<br>";
			//}


			/*
			var loader = new THREE.FontLoader();

			loader.load( 'https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function ( font ) {

				var geometry = new THREE.TextGeometry( 'Hello three.js!', {
					font: font,
					size: 80,
					height: 5,
					curveSegments: 12,
					bevelEnabled: true,
					bevelThickness: 10,
					bevelSize: 8,
					bevelOffset: 0,
					bevelSegments: 5
				} );
			} );
			*/


			///////////////////
			// Shape display //
			///////////////////

			// Create a closed wavey loop to see the shape
			var points = curve.getPoints( 50 );
			var geometry = new THREE.BufferGeometry().setFromPoints( points );

			var material = new THREE.LineBasicMaterial( { color : 0xff0000 } );

			// Create the final object to add to the scene
			var curveObject = new THREE.Line( geometry, material );
			curveObject.position.set(20, 0, 0)
			scene.add(curveObject)

			/////////////////
			/// GUI widget //
			/////////////////
			var gui = new dat.GUI();

			var light = gui.addFolder('Light');
			light.add(params, 'intensity')
					.name('Intensity')
					.min(1).max(20).step(1)
					.onFinishChange(function(){
    			// refresh based on the new value of params.interation
					});

			/////////////
			// Animate //
			/////////////

			var animate = function () {
				requestAnimationFrame( animate );

				var number_face_normal = disk.geometry.faces.length;
				//var number_vertice = disk.geometry.vertices.length;
				initial_vector = new THREE.Vector3( 1, 1, 1 );
				color_vector = camera.getWorldDirection(initial_vector);

				var pLocal = new THREE.Vector3(0,1,0);
				var pWorld = pLocal.applyQuaternion(camera.quaternion);

				var origin = new THREE.Vector3(0,0,0);
				var length = 20;
				var hex = 0xffff00;

				var arrow_up = new THREE.ArrowHelper(pWorld, origin, length, hex);

				for (i = 0; i < number_face_normal; i++) {
					//pos_x = disk.geometry.vertices[i].x;
					//pos_y = disk.geometry.vertices[i].y;
					//pos_z = disk.geometry.vertices[i].z;
					face_normal_x = disk.geometry.faces[i].normal.x;
					face_normal_y = disk.geometry.faces[i].normal.y;
					face_normal_z = disk.geometry.faces[i].normal.z;

					norm = Math.pow(face_normal_x*face_normal_x
						+ face_normal_y*face_normal_y
						+ face_normal_z*face_normal_z,
						0.5);
					// normalize the position vectors
					face_normalized_x = face_normal_x/norm;
					face_normalized_y = face_normal_y/norm;
					face_normalized_z = face_normal_z/norm;
					// dot product
					blag = arrow_up.quaternion.x*face_normalized_x
						+ arrow_up.quaternion.y*face_normalized_y
						+ arrow_up.quaternion.z*face_normalized_z

					setColor = disk.geometry.faces[i].color.setRGB(
						Math.abs(blag),
						Math.abs(blag),
						Math.abs(blag),
					);
				}
				disk.geometry.elementsNeedUpdate = true;
				//var pLocal = new THREE.Vector3(0,1,0);
				//var pWorld = pLocal.applyMatrix4(camera.matrixWorld).normalize();
				//var dir = pWorld.sub(camera.position).normalize();

				//console.log(arrow_up.quaternion.x);
				//console.log(camera.quaternion);
				//console.log(pWorld);


				renderer.render( scene, camera );
			};

			animate();
		</script>
	</body>
</html>
